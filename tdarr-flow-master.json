{
  "_id": "BkcVKAo5k",
  "name": "Media Optimize",
  "description": "Media Optimize",
  "tags": "",
  "flowPlugins": [
    {
      "name": "Custom Arguments",
      "sourceRepo": "Community",
      "pluginName": "ffmpegCommandCustomArguments",
      "version": "1.0.0",
      "id": "UMg0N1g55",
      "position": {
        "x": 780,
        "y": -60
      },
      "fpEnabled": true,
      "inputsDB": {
        "outputArguments": "{{{args.variables.ffmpegMasterCommand}}} -probesize 15M -analyzeduration 30M"
      }
    },
    {
      "name": "Input File",
      "sourceRepo": "Community",
      "pluginName": "inputFile",
      "version": "1.0.0",
      "id": "gtZCtmY-l",
      "position": {
        "x": 780,
        "y": -324
      },
      "fpEnabled": true,
      "inputsDB": {
        "fileAccessChecks": "true",
        "pauseNodeIfAccessChecksFail": "true"
      }
    },
    {
      "name": "Compare File Size",
      "sourceRepo": "Community",
      "pluginName": "compareFileSize",
      "version": "1.0.0",
      "id": "--LuA97TO",
      "position": {
        "x": 780,
        "y": 60
      },
      "fpEnabled": true
    },
    {
      "name": "Move To Done",
      "sourceRepo": "Community",
      "pluginName": "moveToDirectory",
      "version": "2.0.0",
      "id": "oLSxWY1x1",
      "position": {
        "x": 684,
        "y": 132
      },
      "fpEnabled": true,
      "inputsDB": {
        "outputDirectory": "/mnt/media/done",
        "keepRelativePath": "true"
      }
    },
    {
      "name": "Delete Original",
      "sourceRepo": "Community",
      "pluginName": "deleteFile",
      "version": "1.0.0",
      "id": "B8G3Mw1Jr",
      "position": {
        "x": 684,
        "y": 192
      },
      "fpEnabled": true,
      "inputsDB": {
        "deleteParentFolderIfEmpty": "true",
        "fileToDelete": "originalFile"
      }
    },
    {
      "name": "Execute",
      "sourceRepo": "Community",
      "pluginName": "ffmpegCommandExecute",
      "version": "1.0.0",
      "id": "0owKKxeGR",
      "position": {
        "x": 780,
        "y": 0
      },
      "fpEnabled": true
    },
    {
      "name": "Compare File Size Ratio Live",
      "sourceRepo": "Community",
      "pluginName": "compareFileSizeRatioLive",
      "version": "1.0.0",
      "id": "12fGTr1Uk",
      "position": {
        "x": 780,
        "y": -264
      },
      "fpEnabled": true,
      "inputsDB": {
        "checkDelaySeconds": "100",
        "thresholdPerc": "90",
        "enabled": "true"
      }
    },
    {
      "name": "Go To Flow: Audio Only",
      "sourceRepo": "Community",
      "pluginName": "goToFlow",
      "version": "2.0.0",
      "id": "PdNdwqO1d",
      "position": {
        "x": 900,
        "y": 264
      },
      "fpEnabled": true,
      "inputsDB": {
        "flowId": "z1SPtpntR"
      }
    },
    {
      "name": "Reset Flow Error",
      "sourceRepo": "Community",
      "pluginName": "resetFlowError",
      "version": "1.0.0",
      "id": "KmeuSeGql",
      "position": {
        "x": 1068,
        "y": 120
      },
      "fpEnabled": true
    },
    {
      "name": "Check: Live Ratio Error",
      "sourceRepo": "Community",
      "pluginName": "checkFlowVariable",
      "version": "1.0.0",
      "id": "1tMFJj0SN",
      "position": {
        "x": 1092,
        "y": 48
      },
      "fpEnabled": true,
      "inputsDB": {
        "variable": "{{{args.variables.liveSizeCompare.error}}}",
        "value": "true"
      }
    },
    {
      "name": "Fail Flow",
      "sourceRepo": "Community",
      "pluginName": "failFlow",
      "version": "1.0.0",
      "id": "xEwhkOYV8",
      "position": {
        "x": 1260,
        "y": 120
      },
      "fpEnabled": true
    },
    {
      "name": "Disable Live Size Check",
      "sourceRepo": "Community",
      "pluginName": "customFunction",
      "version": "1.0.0",
      "id": "oQ_aAR3ZB",
      "position": {
        "x": 900,
        "y": 192
      },
      "fpEnabled": true,
      "inputsDB": {
        "code": "module.exports = async (args) => {\n  // We reach into the flow variables where Tdarr stores plugin inputs\n  // and manually force the live check to disabled for this flow leg.\n  \n  if (args.variables.liveSizeCompare) {\n    args.variables.liveSizeCompare.enabled = \"false\";\n    args.variables.liveSizeCompare.error = \"false\"; \n  }\n\n  // Also clear the error state so the next Execute doesn't think it failed\n  args.variables.liveSizeCompareError = false;\n\n  return {\n    outputFileObj: args.inputFileObj,\n    outputNumber: 1,\n    variables: args.variables,\n  };\n};"
      }
    },
    {
      "name": "JS: FFmpeg Master",
      "sourceRepo": "Community",
      "pluginName": "customFunction",
      "version": "1.0.0",
      "id": "fV5sAfBTS",
      "position": {
        "x": 780,
        "y": -132
      },
      "fpEnabled": true,
      "inputsDB": {
        "code": "/*\n * MASTER MEDIA PROCESSOR v3.1\n * ---------------------------\n * 1. Resolution & Content Detection\n * 2. Audio Curator (Best German > Channels)\n * 3. Subtitle Deduplication (Prefer PGS over SRT)\n * 4. Smart Default Logic & Language Tagging\n * 5. Tdarr Bypass & Hardware Decode\n */\n\nmodule.exports = async (args) => {\n  try {\n    // --- 1. SETUP & SAFETY ---\n    if (!args.inputFileObj || !args.inputFileObj.ffProbeData) {\n      throw new Error(\"File has not been scanned!\");\n    }\n\n    const file = args.inputFileObj;\n    const streams = file.ffProbeData.streams;\n    const container = file.container || 'mkv';\n    const transcodeVideo = args.variables.transcodeVideo !== \"false\";\n\n    // --- 2. ANALYZE STREAMS (Pre-Calculation) ---\n    \n    // Helper: Check forced status\n    const isForced = (s) => (s.disposition && s.disposition.forced === 1) || (s.tags && s.tags.title && s.tags.title.toLowerCase().includes('forced'));\n    // Helper: Get lang (returns 'ger', 'eng', 'und')\n    const getLang = (s) => (s.tags && s.tags.language ? s.tags.language.toLowerCase() : 'und');\n\n    // A. Find Target Default Audio\n    let germanAudioCandidates = streams.filter(s => s.codec_type === 'audio' && getLang(s) === 'ger');\n    let targetDefaultAudioIndex = -1;\n    \n    if (germanAudioCandidates.length > 0) {\n        // Sort by Channels Descending\n        germanAudioCandidates.sort((a, b) => (b.channels || 0) - (a.channels || 0));\n        targetDefaultAudioIndex = germanAudioCandidates[0].index;\n    } else {\n        // Fallback: Keep original default or first audio\n        const originalDefault = streams.find(s => s.codec_type === 'audio' && s.disposition && s.disposition.default === 1);\n        targetDefaultAudioIndex = originalDefault ? originalDefault.index : (streams.find(s => s.codec_type === 'audio')?.index || -1);\n    }\n\n    const activeAudioStream = streams.find(s => s.index === targetDefaultAudioIndex);\n    const activeAudioLang = activeAudioStream ? getLang(activeAudioStream) : 'und';\n\n    // B. Subtitle Deduplication (PGS vs SRT) & Filtering\n    let pgsRegistry = new Set();\n    \n    // Register PGS\n    streams.forEach(s => {\n        if (s.codec_type === 'subtitle' && s.codec_name === 'hdmv_pgs_subtitle') {\n            const key = `${getLang(s)}_${isForced(s)}`;\n            pgsRegistry.add(key);\n        }\n    });\n\n    // Build valid subtitle list\n    let validSubtitleIndices = [];\n    const allowedSubLangs = ['eng', 'en', 'ger', 'de', 'deu', 'jpn', 'und'];\n    \n    streams.forEach(s => {\n        if (s.codec_type === 'subtitle') {\n            const lang = getLang(s);\n            const forced = isForced(s);\n            const title = (s.tags && s.tags.title || '').toLowerCase();\n            \n            // Filter Junk\n            if (!allowedSubLangs.includes(lang) || title.includes('commentary')) return;\n\n            // Dedupe: Skip SRT if equivalent PGS exists\n            if (s.codec_name === 'subrip' && pgsRegistry.has(`${lang}_${forced}`)) {\n                console.log(`[MasterNode] Removing Duplicate SRT: ${lang} (Forced: ${forced})`);\n                return; \n            }\n            validSubtitleIndices.push(s.index);\n        }\n    });\n\n    // C. Determine Target Default Subtitle\n    let targetDefaultSubIndex = -1;\n\n    // 1. Ger Forced\n    const gerForced = streams.find(s => validSubtitleIndices.includes(s.index) && getLang(s) === 'ger' && isForced(s));\n    if (gerForced) {\n        targetDefaultSubIndex = gerForced.index;\n    } \n    // 2. Eng Forced\n    else {\n        const engForced = streams.find(s => validSubtitleIndices.includes(s.index) && getLang(s) === 'eng' && isForced(s));\n        if (engForced) {\n            targetDefaultSubIndex = engForced.index;\n        }\n        // 3. Audio Match Logic\n        else {\n            if (activeAudioLang === 'jpn') {\n                // If Audio is Japanese, prefer English Subs\n                const engFull = streams.find(s => validSubtitleIndices.includes(s.index) && getLang(s) === 'eng' && !isForced(s));\n                if (engFull) {\n                    targetDefaultSubIndex = engFull.index;\n                } else {\n                    const gerFull = streams.find(s => validSubtitleIndices.includes(s.index) && getLang(s) === 'ger' && !isForced(s));\n                    if (gerFull) targetDefaultSubIndex = gerFull.index;\n                }\n            } else {\n                // If Audio is Ger/Eng, disable full subs\n                targetDefaultSubIndex = -1; \n            }\n        }\n    }\n\n    console.log(`[MasterNode] Audio Def: ${targetDefaultAudioIndex} | Sub Def: ${targetDefaultSubIndex}`);\n\n\n    // --- 3. BUILD COMMAND ---\n    \n    // Video Params\n    const videoStream = streams.find(s => s.codec_type === 'video');\n    const width = videoStream ? (videoStream.width || 1920) : 1920;\n    const height = videoStream ? (videoStream.height || 1080) : 1080;\n    const pixel_count = width * height;\n    const filePath = file._id.toLowerCase();\n    const isAnimation = ['anime', 'cartoon', 'animation'].some(k => filePath.includes(k));\n    \n    let videoArgs = [];\n    if (transcodeVideo) {\n        let crf = '25'; \n        if (pixel_count >= 5000000) crf = '28'; // 4K\n        else if (pixel_count >= 3000000) crf = '26'; // 2K\n        else if (pixel_count >= 1000000) crf = '25'; // HD\n        else crf = '32'; // SD\n        // Animation: Strong Denoise, No Film Grain\n        // Film: Film Grain Synth\n        // Note: hqdn3d is a CPU filter, but very effective for anime\n        let params = isAnimation \n            ? '-vf hqdn3d=1.5:1.5:3:3 -svtav1-params tune=0:enable-overlays=1:scd=1:enable-tf=0'\n            : '-svtav1-params tune=0:enable-overlays=1:scd=1:film-grain=8';\n        videoArgs.push('-c:v', 'libsvtav1', '-preset', '5', '-pix_fmt', 'yuv420p10le', '-crf', crf, params);\n    } else {\n        videoArgs.push('-c:v', 'copy');\n    }\n\n    // Base Command\n    const fileName = file.fileNameWithoutExtension;\n    const safeTitle = fileName.replace(/ /g, '\\u00A0');\n\n    let cmd = [\n        '-map_metadata:g', '-1',\n        '-metadata', `title=${safeTitle}`,\n        '-map_chapters', '0',\n        '-map', '0:v',\n        ...videoArgs\n    ];\n\n    // Audio Loop\n    let audioOutIndex = 0;\n    for (let i = 0; i < streams.length; i++) {\n        const s = streams[i];\n        if (s.codec_type === 'audio') {\n            cmd.push(`-map 0:${i}`);\n            \n            // Codec\n            const channels = s.channels || 2;\n            if (s.codec_name === 'opus') {\n                cmd.push(`-c:a:${audioOutIndex} copy`);\n            } else {\n                let bitrate = channels > 5 ? '448k' : (channels > 2 ? '320k' : '160k');\n                if (channels === 1) bitrate = '96k';\n                cmd.push(`-c:a:${audioOutIndex} libopus`, `-b:a:${audioOutIndex} ${bitrate}`, `-ac:a:${audioOutIndex} ${channels}`);\n            }\n\n            // Disposition (Default/0)\n            const isDef = s.index === targetDefaultAudioIndex ? 'default' : '0';\n            cmd.push(`-disposition:a:${audioOutIndex} ${isDef}`);\n\n            // Metadata: Language & Title\n            const langCode = getLang(s); // 'ger', 'eng'\n            const langUpper = langCode.toUpperCase();\n            let layout = channels === 1 ? '1.0' : channels === 2 ? '2.0' : channels === 6 ? '5.1' : channels === 8 ? '7.1' : `${channels}ch`;\n            \n            // Explicitly set Language tag\n            cmd.push(`-metadata:s:a:${audioOutIndex} language=${langCode}`);\n            // Set friendly Title\n            cmd.push(`-metadata:s:a:${audioOutIndex} title=${langUpper}\\u00A0${layout}`);\n            \n            audioOutIndex++;\n        }\n    }\n\n    // Subtitle Loop\n    let subOutIndex = 0;\n    for (let i = 0; i < streams.length; i++) {\n        const s = streams[i];\n        if (s.codec_type === 'subtitle') {\n            if (!validSubtitleIndices.includes(s.index)) continue;\n\n            cmd.push(`-map 0:${i}`);\n            cmd.push(`-c:s:${subOutIndex} copy`);\n\n            // Disposition\n            const isDef = s.index === targetDefaultSubIndex ? 'default' : '0';\n            cmd.push(`-disposition:s:${subOutIndex} ${isDef}`);\n\n            // Metadata: Language & Title\n            const langCode = getLang(s);\n            const originalTitle = s.tags && s.tags.title ? s.tags.title : '';\n            \n            // Explicitly set Language tag\n            cmd.push(`-metadata:s:s:${subOutIndex} language=${langCode}`);\n            if (originalTitle) {\n                cmd.push(`-metadata:s:s:${subOutIndex} title=${originalTitle.replace(/ /g, '\\u00A0')}`);\n            }\n            \n            subOutIndex++;\n        }\n    }\n\n    // Attachments\n    cmd.push('-map 0:t?', '-c:t copy', '-map_metadata:s:t 0:s:t');\n\n    // Finalize\n    const finalString = cmd.join(' ');\n    console.log(\"Master Generated Command:\", finalString);\n    args.variables.ffmpegMasterCommand = finalString;\n\n    // --- 4. BYPASS OBJECT ---\n    const dummyStream = {\n        ...(videoStream || streams[0]), \n        removed: false,\n        mapArgs: [], \n        inputArgs: [],\n        outputArgs: []\n    };\n\n    args.variables.ffmpegCommand = {\n        init: true,\n        inputFiles: [],\n        streams: [dummyStream], \n        container: container,\n        hardwareDecoding: false,\n        shouldProcess: false,\n        overallInputArguments: [],\n        overallOuputArguments: [],\n    };\n\n    args.variables.ffmpegInputArguments = \"-hwaccel auto\";\n\n    return {\n        outputFileObj: args.inputFileObj,\n        outputNumber: 1,\n        variables: args.variables,\n    };\n\n  } catch (err) {\n    console.error(\"Master Node Error:\", err);\n    throw err;\n  }\n};"
      }
    },
    {
      "name": "Enable: Transcode Video",
      "sourceRepo": "Community",
      "pluginName": "setFlowVariable",
      "version": "1.0.0",
      "id": "ZG-o1DxXl",
      "position": {
        "x": 780,
        "y": -192
      },
      "fpEnabled": true,
      "inputsDB": {
        "variable": "transcodeVideo",
        "value": "true"
      }
    }
  ],
  "flowEdges": [
    {
      "source": "--LuA97TO",
      "sourceHandle": "1",
      "target": "oLSxWY1x1",
      "targetHandle": null,
      "id": "RQAf6cMkz"
    },
    {
      "source": "oLSxWY1x1",
      "sourceHandle": "1",
      "target": "B8G3Mw1Jr",
      "targetHandle": null,
      "id": "atDsioaxF"
    },
    {
      "source": "0owKKxeGR",
      "sourceHandle": "1",
      "target": "--LuA97TO",
      "targetHandle": null,
      "id": "qp52Yea1L"
    },
    {
      "source": "12fGTr1Uk",
      "sourceHandle": "err1",
      "target": "8u9KMlnrY",
      "targetHandle": null,
      "id": "sGaopaV7V"
    },
    {
      "source": "0owKKxeGR",
      "sourceHandle": "err1",
      "target": "1tMFJj0SN",
      "targetHandle": null,
      "id": "27OJL86po"
    },
    {
      "source": "1tMFJj0SN",
      "sourceHandle": "1",
      "target": "KmeuSeGql",
      "targetHandle": null,
      "id": "QxbaDQKR7"
    },
    {
      "source": "1tMFJj0SN",
      "sourceHandle": "2",
      "target": "xEwhkOYV8",
      "targetHandle": null,
      "id": "LjbrURIui"
    },
    {
      "source": "UMg0N1g55",
      "sourceHandle": "1",
      "target": "0owKKxeGR",
      "targetHandle": null,
      "id": "D8iD68lXa"
    },
    {
      "source": "KmeuSeGql",
      "sourceHandle": "1",
      "target": "oQ_aAR3ZB",
      "targetHandle": null,
      "id": "fYmgqy3WF"
    },
    {
      "source": "--LuA97TO",
      "sourceHandle": "2",
      "target": "oQ_aAR3ZB",
      "targetHandle": null,
      "id": "i9jGshKYc"
    },
    {
      "source": "--LuA97TO",
      "sourceHandle": "3",
      "target": "oQ_aAR3ZB",
      "targetHandle": null,
      "id": "30ZXyOt4g"
    },
    {
      "source": "oQ_aAR3ZB",
      "sourceHandle": "1",
      "target": "PdNdwqO1d",
      "targetHandle": null,
      "id": "oM4xLDq3V"
    },
    {
      "source": "fV5sAfBTS",
      "sourceHandle": "1",
      "target": "UMg0N1g55",
      "targetHandle": null,
      "id": "74_kXLg79"
    },
    {
      "source": "gtZCtmY-l",
      "sourceHandle": "1",
      "target": "12fGTr1Uk",
      "targetHandle": null,
      "id": "MmvhA3qmr"
    },
    {
      "source": "12fGTr1Uk",
      "sourceHandle": "1",
      "target": "ZG-o1DxXl",
      "targetHandle": null,
      "id": "fArK6t2B3"
    },
    {
      "source": "ZG-o1DxXl",
      "sourceHandle": "1",
      "target": "fV5sAfBTS",
      "targetHandle": null,
      "id": "QwZx7d3Zr"
    }
  ]
}